# apps/payments/views.py
# ==========================

from decimal import Decimal
from rest_framework import status, generics, permissions, viewsets
from rest_framework.decorators import api_view, permission_classes, action
from rest_framework.response import Response
from rest_framework.views import APIView
from django.utils.translation import gettext_lazy as _
from django.utils import timezone
from django.db import transaction
from django.db.models import Sum, Q, Count
from django_ratelimit.decorators import ratelimit
from django.utils.decorators import method_decorator

from .models import (
    PaymentMethod, Transaction, Wallet, WithdrawalRequest,
    PaymentWebhook, ExchangeRate, PaymentSettings
)
from .serializers import (
    PaymentMethodSerializer, TransactionSerializer, WalletSerializer,
    WithdrawalRequestSerializer, DepositRequestSerializer,
    PaymentStatisticsSerializer, FeeCalculatorSerializer,
    CurrencyConversionSerializer, ExchangeRateSerializer
)
from apps.accounts.permissions import (
    IsVerifiedUser, IsKYCApproved, CanWithdraw, CanDeposit,
    HasSufficientBalance, HighValueTransactionPermissions
)
from apps.core.permissions import IsOwnerOrReadOnly
from apps.core.utils import log_user_activity, get_client_ip
from apps.core.pagination import StandardResultsSetPagination

from .processors import get_payment_processor


class PaymentMethodListView(generics.ListAPIView):
    """Vue pour lister les méthodes de paiement disponibles."""
    
    serializer_class = PaymentMethodSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """Retourner les méthodes actives, filtrées selon l'utilisateur."""
        queryset = PaymentMethod.objects.filter(is_active=True)
        
        # Filtrer selon les permissions utilisateur
        user = self.request.user
        transaction_type = self.request.query_params.get('type', 'deposit')
        
        if transaction_type == 'withdrawal' and user.kyc_status != 'approved':
            # Limiter aux méthodes ne nécessitant pas KYC
            queryset = queryset.exclude(method_type__in=['card', 'bank_transfer', 'crypto'])
        
        return queryset.order_by('name')


class TransactionListView(generics.ListAPIView):
    """Vue pour lister les transactions de l'utilisateur."""
    
    serializer_class = TransactionSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly]
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        """Retourner les transactions de l'utilisateur connecté."""
        queryset = Transaction.objects.filter(user=self.request.user)
        print("User Transactions Queryset:", queryset)
        
        # Filtres optionnels
        transaction_type = self.request.query_params.get('type')
        if transaction_type:
            queryset = queryset.filter(transaction_type=transaction_type)
        
        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)
        
        currency = self.request.query_params.get('currency')
        if currency:
            queryset = queryset.filter(currency=currency)
        
        return queryset.order_by('-created_at')


class TransactionDetailView(generics.RetrieveAPIView):
    """Vue pour consulter le détail d'une transaction."""
    
    serializer_class = TransactionSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly]
    
    def get_queryset(self):
        """Retourner les transactions de l'utilisateur."""
        return Transaction.objects.filter(user=self.request.user)


class DepositCreateView(generics.CreateAPIView):
    """Vue pour créer une demande de dépôt."""
    
    serializer_class = DepositRequestSerializer
    permission_classes = [permissions.IsAuthenticated, IsVerifiedUser, CanDeposit]
    
    @method_decorator(ratelimit(key='user', rate='10/h', method='POST'))
    def post(self, request, *args, **kwargs):
        """Créer une demande de dépôt avec limitation."""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        with transaction.atomic():
            # Créer la transaction de dépôt
            deposit_transaction = self._create_deposit_transaction(
                serializer.validated_data
            )
            
            # Initier le processus de paiement
            payment_result = self._initiate_payment(
                deposit_transaction,
                serializer.validated_data
            )
            
            # Logger l'activité
            log_user_activity(
                user=request.user,
                activity_type='withdrawal_requested',
                description=f'Retrait demandé: {withdrawal_request.amount} {withdrawal_request.currency}',
                metadata={
                    'withdrawal_id': str(withdrawal_request.id),
                    'transaction_id': str(withdrawal_transaction.id),
                    'payment_method': str(withdrawal_request.payment_method.id),
                    'amount': str(withdrawal_request.amount),
                    'auto_approved': self._should_auto_approve(withdrawal_request)
                }
            )
            
            return Response({
                'success': True,
                'message': _('Demande de retrait créée avec succès'),
                'withdrawal_request': WithdrawalRequestSerializer(withdrawal_request).data,
                'estimated_processing_time': withdrawal_request.payment_method.withdrawal_processing_time
            }, status=status.HTTP_201_CREATED)
    
    def _check_withdrawal_conditions(self, validated_data):
        """Vérifier les conditions spéciales de retrait."""
        user = self.request.user
        amount = validated_data['amount']
        
        # Règle des 60% - vérifier l'utilisation des dépôts
        settings = PaymentSettings.get_settings()
        usage_requirement = settings.deposit_usage_requirement / 100
        
        # Calculer les dépôts et mises
        total_deposits = Transaction.objects.filter(
            user=user,
            transaction_type='deposit',
            status='completed'
        ).aggregate(Sum('amount'))['amount__sum'] or Decimal('0')
        
        total_bets = Transaction.objects.filter(
            user=user,
            transaction_type='bet',
            status='completed'
        ).aggregate(Sum('amount'))['amount__sum'] or Decimal('0')
        
        required_usage = total_deposits * usage_requirement
        
        if total_bets < required_usage:
            remaining = required_usage - total_bets
            raise serializers.ValidationError(
                _('Vous devez miser au moins {} FCFA avant de pouvoir retirer ({}% de vos dépôts)')
                .format(remaining, settings.deposit_usage_requirement)
            )
    
    def _create_withdrawal_transaction(self, validated_data):
        """Créer la transaction de retrait."""
        payment_method = validated_data['payment_method']
        
        # Calculer les frais
        fees_info = payment_method.calculate_fees(
            validated_data['amount'],
            'withdrawal'
        )
        
        # Créer la transaction
        transaction_obj = Transaction.objects.create(
            user=self.request.user,
            transaction_type='withdrawal',
            amount=validated_data['amount'],
            currency=validated_data['currency'],
            payment_method=payment_method,
            fees=fees_info['total_fees'],
            net_amount=fees_info['net_amount'],
            status='pending',
            ip_address=get_client_ip(self.request),
            user_agent=self.request.META.get('HTTP_USER_AGENT', '')
        )
        
        return transaction_obj
    
    def _lock_withdrawal_funds(self, withdrawal_request):
        """Bloquer les fonds pour le retrait."""
        user = withdrawal_request.user
        currency = withdrawal_request.currency
        amount = withdrawal_request.amount
        
        # Débiter temporairement le solde
        user.update_balance(currency, amount, 'subtract')
    
    def _should_auto_approve(self, withdrawal_request):
        """Vérifier si le retrait doit être auto-approuvé."""
        settings = PaymentSettings.get_settings()
        
        # Auto-approuver si montant inférieur à la limite
        if withdrawal_request.amount <= settings.auto_approval_limit:
            return True
        
        # Auto-approuver pour les utilisateurs VIP (à implémenter)
        # if withdrawal_request.user.is_vip:
        #     return True
        
        return False


class WithdrawalListView(generics.ListAPIView):
    """Vue pour lister les demandes de retrait de l'utilisateur."""
    
    serializer_class = WithdrawalRequestSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly]
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        """Retourner les demandes de retrait de l'utilisateur."""
        return WithdrawalRequest.objects.filter(
            user=self.request.user
        ).order_by('-created_at')


class WithdrawalDetailView(generics.RetrieveAPIView):
    """Vue pour consulter le détail d'une demande de retrait."""
    
    serializer_class = WithdrawalRequestSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly]
    
    def get_queryset(self):
        """Retourner les demandes de retrait de l'utilisateur."""
        return WithdrawalRequest.objects.filter(user=self.request.user)


class WithdrawalCancelView(APIView):
    """Vue pour annuler une demande de retrait."""
    
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request, pk):
        """Annuler une demande de retrait."""
        try:
            withdrawal_request = WithdrawalRequest.objects.get(
                id=pk,
                user=request.user,
                status='pending'
            )
            
            with transaction.atomic():
                # Rembourser les fonds
                withdrawal_request.user.update_balance(
                    withdrawal_request.currency,
                    withdrawal_request.amount,
                    'add'
                )
                
                # Annuler la transaction
                withdrawal_request.transaction.cancel('Cancelled by user')
                
                # Mettre à jour le statut
                withdrawal_request.status = 'cancelled'
                withdrawal_request.save()
                
                # Logger l'activité
                log_user_activity(
                    user=request.user,
                    activity_type='withdrawal_cancelled',
                    description=f'Retrait annulé: {withdrawal_request.amount} {withdrawal_request.currency}',
                    metadata={'withdrawal_id': str(withdrawal_request.id)}
                )
                
                return Response({
                    'success': True,
                    'message': _('Demande de retrait annulée avec succès')
                })
                
        except WithdrawalRequest.DoesNotExist:
            return Response({
                'success': False,
                'error': _('Demande de retrait introuvable ou non annulable')
            }, status=status.HTTP_404_NOT_FOUND)


class WalletListView(generics.ListAPIView):
    """Vue pour lister les portefeuilles de l'utilisateur."""
    
    serializer_class = WalletSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """Retourner les portefeuilles de l'utilisateur."""
        return Wallet.objects.filter(user=self.request.user)


class TransactionCancelView(APIView):
    """Vue pour annuler une transaction."""
    
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request, pk):
        """Annuler une transaction."""
        try:
            transaction_obj = Transaction.objects.get(
                id=pk,
                user=request.user
            )
            
            if not transaction_obj.can_cancel():
                return Response({
                    'success': False,
                    'error': _('Cette transaction ne peut pas être annulée')
                }, status=status.HTTP_400_BAD_REQUEST)
            
            # Annuler la transaction
            transaction_obj.cancel('Cancelled by user')
            
            # Logger l'activité
            log_user_activity(
                user=request.user,
                activity_type='transaction_cancelled',
                description=f'Transaction annulée: {transaction_obj.transaction_id}',
                metadata={'transaction_id': str(transaction_obj.id)}
            )
            
            return Response({
                'success': True,
                'message': _('Transaction annulée avec succès')
            })
            
        except Transaction.DoesNotExist:
            return Response({
                'success': False,
                'error': _('Transaction introuvable')
            }, status=status.HTTP_404_NOT_FOUND)


class PaymentStatisticsView(APIView):
    """Vue pour les statistiques de paiement de l'utilisateur."""
    
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request):
        """Obtenir les statistiques de paiement."""
        serializer = PaymentStatisticsSerializer(request.user)
        return Response(serializer.data)


class FeeCalculatorView(APIView):
    """Vue pour calculer les frais de transaction."""
    
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        """Calculer les frais pour une transaction."""
        serializer = FeeCalculatorSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        fee_calculation = serializer.get_fee_calculation()
        
        return Response({
            'success': True,
            'fees': fee_calculation
        })


class CurrencyConversionView(APIView):
    """Vue pour convertir entre devises."""
    
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        """Convertir un montant entre devises."""
        serializer = CurrencyConversionSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        try:
            conversion = serializer.get_conversion()
            
            return Response({
                'success': True,
                'conversion': conversion
            })
            
        except Exception as e:
            return Response({
                'success': False,
                'error': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)


class ExchangeRateListView(generics.ListAPIView):
    """Vue pour lister les taux de change."""
    
    serializer_class = ExchangeRateSerializer
    permission_classes = [permissions.AllowAny]
    
    def get_queryset(self):
        """Retourner les taux de change actifs."""
        return ExchangeRate.objects.filter(is_active=True)


class PaymentWebhookView(APIView):
    """Vue pour recevoir les webhooks de paiement."""
    
    permission_classes = [permissions.AllowAny]
    
    def post(self, request, provider):
        """Recevoir un webhook d'un fournisseur de paiement."""
        # Créer l'enregistrement webhook
        webhook = PaymentWebhook.objects.create(
            provider=provider,
            event_type=request.data.get('type', 'unknown'),
            payload=request.data,
            headers=dict(request.META),
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        # Traiter le webhook de manière asynchrone
        try:
            webhook.process_webhook()
            
            return Response({
                'success': True,
                'webhook_id': str(webhook.id)
            })
            
        except Exception as e:
            return Response({
                'success': False,
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# ViewSets pour une API plus complète
class PaymentMethodViewSet(viewsets.ReadOnlyModelViewSet):
    """ViewSet pour les méthodes de paiement."""
    
    serializer_class = PaymentMethodSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """Retourner les méthodes actives."""
        return PaymentMethod.objects.filter(is_active=True)
    
    @action(detail=True, methods=['post'])
    def calculate_fees(self, request, pk=None):
        """Calculer les frais pour cette méthode."""
        payment_method = self.get_object()
        amount = Decimal(request.data.get('amount', '0'))
        transaction_type = request.data.get('type', 'deposit')
        
        if amount <= 0:
            return Response({
                'error': _('Montant invalide')
            }, status=status.HTTP_400_BAD_REQUEST)
        
        fees = payment_method.calculate_fees(amount, transaction_type)
        
        return Response({
            'success': True,
            'fees': fees
        })


class TransactionViewSet(viewsets.ReadOnlyModelViewSet):
    """ViewSet pour les transactions."""
    
    serializer_class = TransactionSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerOrReadOnly]
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        """Retourner les transactions de l'utilisateur."""
        return Transaction.objects.filter(user=self.request.user)
    
    @action(detail=True, methods=['post'])
    def cancel(self, request, pk=None):
        """Annuler une transaction."""
        transaction_obj = self.get_object()
        
        if not transaction_obj.can_cancel():
            return Response({
                'success': False,
                'error': _('Cette transaction ne peut pas être annulée')
            }, status=status.HTTP_400_BAD_REQUEST)
        
        transaction_obj.cancel('Cancelled by user')
        
        return Response({
            'success': True,
            'message': _('Transaction annulée')
        })
    
    @action(detail=False, methods=['get'])
    def summary(self, request):
        """Résumé des transactions."""
        queryset = self.get_queryset().filter(status='completed')
        
        summary = {}
        for tx_type in ['deposit', 'withdrawal', 'bet', 'win']:
            transactions = queryset.filter(transaction_type=tx_type)
            summary[tx_type] = {
                'count': transactions.count(),
                'total': transactions.aggregate(Sum('amount'))['amount__sum'] or 0
            }
        
        return Response(summary)


# Vues administratives (pour le staff)
class AdminWithdrawalApprovalView(APIView):
    """Vue pour approuver/rejeter les retraits (admin seulement)."""
    
    permission_classes = [permissions.IsAuthenticated, permissions.IsAdminUser]
    
    def post(self, request, pk):
        """Approuver ou rejeter une demande de retrait."""
        try:
            withdrawal_request = WithdrawalRequest.objects.get(
                id=pk,
                status='pending'
            )
            
            action = request.data.get('action')  # 'approve' ou 'reject'
            notes = request.data.get('notes', '')
            reason = request.data.get('reason', '')
            
            if action == 'approve':
                withdrawal_request.approve(request.user, notes)
                message = _('Demande de retrait approuvée')
                
            elif action == 'reject':
                withdrawal_request.reject(request.user, reason)
                message = _('Demande de retrait rejetée')
                
            else:
                return Response({
                    'error': _('Action invalide')
                }, status=status.HTTP_400_BAD_REQUEST)
            
            return Response({
                'success': True,
                'message': message
            })
            
        except WithdrawalRequest.DoesNotExist:
            return Response({
                'error': _('Demande de retrait introuvable')
            }, status=status.HTTP_404_NOT_FOUND)


class AdminTransactionListView(generics.ListAPIView):
    """Vue pour lister toutes les transactions (admin)."""
    
    serializer_class = TransactionSerializer
    permission_classes = [permissions.IsAuthenticated, permissions.IsAdminUser]
    pagination_class = StandardResultsSetPagination
    
    def get_queryset(self):
        """Retourner toutes les transactions avec filtres."""
        queryset = Transaction.objects.all()
        
        # Filtres
        user_id = self.request.query_params.get('user_id')
        if user_id:
            queryset = queryset.filter(user__id=user_id)
        
        tx_type = self.request.query_params.get('type')
        if tx_type:
            queryset = queryset.filter(transaction_type=tx_type)
        
        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)
        
        return queryset.order_by('-created_at')


# Vues pour les rapports et analytics
class PaymentAnalyticsView(APIView):
    """Vue pour les analytics de paiement (admin)."""
    
    permission_classes = [permissions.IsAuthenticated, permissions.IsAdminUser]
    
    def get(self, request):
        """Obtenir les analytics de paiement."""
        # Transactions par statut
        transactions_by_status = Transaction.objects.values('status').annotate(
            count=Count('id'),
            total_amount=Sum('amount')
        )
        
        # Transactions par type
        transactions_by_type = Transaction.objects.filter(
            status='completed'
        ).values('transaction_type').annotate(
            count=Count('id'),
            total_amount=Sum('amount')
        )
        
        # Volume quotidien des 30 derniers jours
        from datetime import timedelta
        thirty_days_ago = timezone.now() - timedelta(days=30)
        
        daily_volume = Transaction.objects.filter(
            status='completed',
            created_at__gte=thirty_days_ago
        ).extra(
            select={'day': 'date(created_at)'}
        ).values('day').annotate(
            total_amount=Sum('amount'),
            count=Count('id')
        ).order_by('day')
        
        # Méthodes de paiement populaires
        popular_methods = Transaction.objects.filter(
            status='completed',
            payment_method__isnull=False
        ).values(
            'payment_method__name'
        ).annotate(
            count=Count('id'),
            total_amount=Sum('amount')
        ).order_by('-count')
        
        return Response({
            'transactions_by_status': list(transactions_by_status),
            'transactions_by_type': list(transactions_by_type),
            'daily_volume': list(daily_volume),
            'popular_methods': list(popular_methods)
        })


# Vue pour les tests de paiement (développement seulement)
if settings.DEBUG:
    
    class TestPaymentView(APIView):
        """Vue de test pour les paiements (développement seulement)."""
        
        permission_classes = [permissions.IsAuthenticated]
        
        def post(self, request):
            """Simuler une transaction de test."""
            transaction_type = request.data.get('type', 'deposit')
            amount = Decimal(request.data.get('amount', '100'))
            currency = request.data.get('currency', 'FCFA')
            
            # Créer une transaction de test
            test_transaction = Transaction.objects.create(
                user=request.user,
                transaction_type=transaction_type,
                amount=amount,
                currency=currency,
                status='completed',
                metadata={'test': True, 'simulated': True}
            )
            
            # Traiter selon le type
            if transaction_type == 'deposit':
                request.user.update_balance(currency, amount, 'add')
            elif transaction_type == 'withdrawal':
                if request.user.get_balance(currency) >= amount:
                    request.user.update_balance(currency, amount, 'subtract')
                else:
                    test_transaction.status = 'failed'
                    test_transaction.failure_reason = 'Insufficient funds'
                    test_transaction.save()
            
            return Response({
                'success': True,
                'message': f'Transaction de test {transaction_type} créée',
                'transaction': TransactionSerializer(test_transaction).data
            })

            log_user_activity(
                user=request.user,
                activity_type='deposit_requested',
                description=f'Dépôt demandé: {deposit_transaction.amount} {deposit_transaction.currency}',
                metadata={
                    'transaction_id': str(deposit_transaction.id),
                    'payment_method': str(deposit_transaction.payment_method.id),
                    'amount': str(deposit_transaction.amount)
                }
            )
            
            return Response({
                'success': True,
                'message': _('Demande de dépôt créée avec succès'),
                'transaction': TransactionSerializer(deposit_transaction).data,
                'payment_details': payment_result
            }, status=status.HTTP_201_CREATED)
    
    def _create_deposit_transaction(self, validated_data):
        """Créer la transaction de dépôt."""
        payment_method = PaymentMethod.objects.get(
            id=validated_data['payment_method_id']
        )
        
        # Calculer les frais
        fees_info = payment_method.calculate_fees(
            validated_data['amount'],
            'deposit'
        )
        
        # Créer la transaction
        transaction_obj = Transaction.objects.create(
            user=self.request.user,
            transaction_type='deposit',
            amount=validated_data['amount'],
            currency=validated_data['currency'],
            payment_method=payment_method,
            fees=fees_info['total_fees'],
            net_amount=fees_info['net_amount'],
            status='pending',
            metadata=validated_data.get('metadata', {}),
            ip_address=get_client_ip(self.request),
            user_agent=self.request.META.get('HTTP_USER_AGENT', '')
        )
        
        return transaction_obj
    
    def _initiate_payment(self, transaction_obj, validated_data):
        """Initier le processus de paiement."""
        processor = get_payment_processor(transaction_obj.payment_method.method_type)
        
        payment_data = {
            'transaction_id': str(transaction_obj.id),
            'amount': transaction_obj.amount,
            'currency': transaction_obj.currency,
            'return_url': validated_data.get('return_url'),
            'user_email': transaction_obj.user.email,
            'metadata': transaction_obj.metadata
        }
        
        try:
            result = processor.create_payment(payment_data)
            
            # Mettre à jour la référence externe
            if result.get('external_reference'):
                transaction_obj.external_reference = result['external_reference']
                transaction_obj.save()
            
            return result
            
        except Exception as e:
            # Marquer la transaction comme échouée
            transaction_obj.status = 'failed'
            transaction_obj.failure_reason = str(e)
            transaction_obj.save()
            raise


class WithdrawalCreateView(generics.CreateAPIView):
    """Vue pour créer une demande de retrait."""
    
    serializer_class = WithdrawalRequestSerializer
    permission_classes = [
        permissions.IsAuthenticated, IsVerifiedUser,
        IsKYCApproved, CanWithdraw
    ]
    
    @method_decorator(ratelimit(key='user', rate='5/h', method='POST'))
    def post(self, request, *args, **kwargs):
        """Créer une demande de retrait avec limitation stricte."""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        with transaction.atomic():
            # Vérifier les conditions spéciales
            self._check_withdrawal_conditions(serializer.validated_data)
            
            # Créer la transaction de retrait
            withdrawal_transaction = self._create_withdrawal_transaction(
                serializer.validated_data
            )
            
            # Créer la demande de retrait
            withdrawal_request = serializer.save(
                user=request.user,
                transaction=withdrawal_transaction
            )
            
            # Bloquer les fonds
            self._lock_withdrawal_funds(withdrawal_request)
            
            # Auto-approbation si montant faible
            if self._should_auto_approve(withdrawal_request):
                withdrawal_request.approve(
                    admin_user=None,  # Auto-approuvé
                    notes='Auto-approuvé (montant faible)'
                )
            
            # Logger l'activité
